# Cookieとセッション  

## なにこれ



## HTTPはステートレスなプロトコル    
HTTPはステートレスなプロトコルと呼ばれています。  
ステートレスというのは、１つのリクエスト・レスポンスで処理が完結しており、複数のリクエスト間で関連が無いことです。  

この特性のおかげでHTTPはシンプルなプロトコルとなったのですが、実際に使う際には困ることがあります。  

例えばECサイトなどで以下の処理をする場合です。  

1. 商品Aをカートに入れる  
（カート一覧画面に商品Aが表示される）  

1. 商品Bをカートに入れる  
（カート一覧画面に商品Aと商品Bが表示される）  

1. 注文する  
（商品Aと商品Bの注文が完了した旨が表示される）  

前述したとおり、各リクエストは単独で完結しており前後のリクエストとは関連しません。  
その為、これを実現する為にはクライアント側で情報を保持して置き、各リクエストの度に全ての情報を送らなくてはいけません。  
以下のようなイメージです。  

1. 商品Aをカートに入れる  

1. 商品Aと商品Bをカートに入れる  

1. 商品Aと商品Bをカートに入れて注文する  


このような場合に対応するために、HTTPにはCookieという仕組みが用意されています。  


## Cookieとは  
Cookieとはサーバーとクライアントがやり取りする文字列です。  
まずサーバー側がHTTPレスポンスにてクライアントにCookieを送信します。  

Cookieを記述する箇所はレスポンスヘッダーです。  
`set-cookie`というヘッダーにて、`Cookie名=値`という形式で値を指定します。  
`set-cookie`ヘッダーは複数指定可能です。  
また、同じCookie名が返ってきた場合は上書きされます。  

例  

```
HTTP/2.0 200 OK  
Content-Type: text/html  
Set-Cookie: my_cookie1=aaaaa  
Set-Cookie: my_cookie2=bbbbb  
```

このレスポンスが返ってくると、ブラウザはリクエストを送信したドメインと、cookie情報を保存します。  
これ以降、同じドメインに対するHTTPリクエストのリクエストヘッダーに、保存したcookie情報が自動的に追加されます。  
ヘッダー名は`Cookie`で、`Cookie名=値`という形式で値を指定します。   
複数送る場合はセミコロン`;`で区切って記載します。  

例  

```
GET /sample_page.html HTTP/2.0
Host: www.example.org
Cookie: my_cookie1=aaaaa; my_cookie2=bbbbb
```

図  

#### Cookieの有効期限  
また、サーバーからCookieを送信する際に、Cookieの有効期限を指定することも可能です。   

```
Set-Cookie: my_cookie1=aaaaa; Expires=Thu, 31 Oct 2022 07:28:00 GMT;
``` 
有効期限が指定されていないものは、ブラウザを閉じると削除されます。  
指定されていればローカルディスクに保存され、ブラウザを閉じても削除されません。  
ブラウザは有効期限が切れていないCookieのみを送信します。  

### 最初の例でCookieを用いると  
最初の例でCookieを用いると、以下のように処理出来ます。  

（後述しますが、セキュリティの問題等がある為、実際にはこのような使い方をすることはありません。  
あくまで動作イメージをつかむためのものと思ってください。）  

1. 商品Aをカートに入れる  

リクエスト 
``` 
POST /cart/A HTTP/2.0
Host: www.example.org
```

レスポンス  
```
HTTP/2.0 200 OK
Set-Cookie: cart_item1=A  
```


1. 商品Bをカートに入れる  

リクエスト 
``` 
POST /cart/B HTTP/2.0
Host: www.example.org
Cookie: cart_item1=A
```

レスポンス  
```
HTTP/2.0 200 OK
Set-Cookie: cart_item2=B  
```

1. 注文する  

リクエスト 
``` 
POST /order HTTP/2.0
Host: www.example.org
Cookie: cart_item1=A; cart_item2=B
```

レスポンス  
```
HTTP/2.0 200 OK
```

図  



ただ、このようなCookieの利用方法には以下の問題があります。  

- Cookieの値がローカルディスクに保存されるため、機密情報が個人情報が含まれたデータをやり取りするのはセキュリティ的に問題がある。  
- Cookieが増えるとリクエストのサイズが増大していく。  
- 記述方法に制限があり、配列などのデータを表現しにくい。  

そのような問題に対応する為、セッションという仕組みを利用します。  

## セッション
セッションを簡単に説明すると「サーバ内に情報を保存し、リクエスト間で共有する」仕組みのことです。  
大まかな処理の流れは以下になります。  

1. （サーバー）最初にリクエストが来た時に、データを保存する領域を確保  
（以下セッション情報と呼びます）

1. （サーバー）その情報にアクセスするためのキー情報を作成し、HTTPレスポンスで返却  
ここでキー情報を返却する際にcookieを利用します。  
(他にも返却方法はありますが、広く使われているのはcookieを利用する方法です。)  

1. （クライアント）2度目以降のリクエストで最初のレスポンスで返却されたキー情報を送信  
Cookieを利用していればブラウザが自動でリクエストヘッダーを追加してくれます。  

1. （サーバー）処理の内容によって、キー情報に対応するセッション情報にデータを保存したり、データを取り出したりする。  

図  

よくある使い方は以下になります。  
- ログイン時のリクエストで、ID、passwordが正しければセッションにログインしたユーザーの情報を保存  
- 以降のリクエスト（例えばマイページの表示）では、セッションからユーザー情報を取り出し、それをもとにページを表示  
セッションにユーザー情報が登録されていなければ未ログインと判定し、エラーなりログイン画面にリダイレクトさせるなりの処理を行う。  

図  


以下もう少し詳しく説明します。   

1. （サーバー）最初にリクエストが来た時に、データを保存する領域を確保  
最初にリクエストが来たかどうかは、リクエストにセッションのキー情報が含まれているかで判断します。  
（含まれていなければ最初のリクエストと判断します。   
また正確には、最初のリクエストでかつサーバー側でセッション情報にアクセスした際に領域を確保します。）  

データを保存する領域とは、JavaのmapやC#のDictionary的な、キーバリュー型の変数です。    
これをセッション情報と呼びます。  

そしてその変数を、システムが用意しているセッション全体を管理する為のさらに大きなキーバリュー型の変数に設定します。  
(システムが用意した1つの大きなキーバリュー型の入れ物に、各セッション情報を保持するキーバリュー側の入れ物を設定するイメージです。)  

変数に設定する際のキー情報は、既に使用済みのキーとは重複しない値を設定する必要があります。
また推測されないよう十分な長さの文字列でなくてはいけません。  
(主要なWebシステムのライブラリにはそのようなセッションキーを作成する為の関数が用意されています。)   
このキー情報を**セッションID**などと呼びます。  

図  

1. （サーバー）その情報にアクセスするためのキー情報を作成し、HTTPレスポンスで返却  
前の手順で作成したキー情報（以下セッションIDと呼びます）を、クライアントに返却します。  
Cookieとして返却することが一般的です。  
```
Set-Cookie: SESSION_ID=d1343kajfaolgiadifjadfae

```  


1. （クライアント）2度目以降のリクエストで最初のレスポンスで返却されたセッションIDを送信  
Cookieを利用していればブラウザが自動でリクエストヘッダーを追加してくれます。    

```
Cookie: SESSION_ID=d1343kajfaolgiadifjadfae

```  

1. （サーバー）処理の内容によって、セッションIDに対応するセッション情報にデータを保存したり、データを取り出したりする。  

セッション全体を管理する領域からセッションIDに対応するセッション情報を取得する処理は、フレームワーク側でやってくれることが多いです。  

それを利用する場合は以下のようなコードを記述します。  
```


```


セッションIDはそれぞれのクライアント毎に発行される事になるので、別のクライアントのセッション情報が見れてしまうことはありません。  

図  

### セッション情報の保存先
セッション情報は主に以下に保存されます。  

- サーバーのメモリ  
- DB  
- DB以外の高速なデータストア(Redisなど)  

サーバーのメモリが一番手軽ですが、サーバーを複数台構成にした場合に同期がとれません。  
またサーバーアプリを再起動した場合にセッション情報がクリアされてしまいます。  

その為、DBなどのAppサーバー外にセッション情報を保持する事も多いです。  

ただセッション情報は頻繁にアクセスされるため、DBよりも処理が高速なデータストア(Redisなど)が利用されることも多いです。  


### セッションの有効期限
セッションの有効期限には２つの側面があります。  

- サーバーのセッション変数の有効期限

- クライアントに返却したセッションIDのCookieの有効期限  

この２つの情報のいずれかが欠けると、いままでセッションに保存したデータが利用できなくなります。  
（新しいセッションとして認識されます。）  

例えばCookieの有効期限を長くしても、（セッション情報をメモリ上に保持していた場合に）サーバー側を再起動した場合などはセッションの情報が空になります。  
サーバー側のフレームワークにもよりますが、この場合新しいセッションIDが発行されることが多いです。  

またサーバー側のセッション情報が残っていても、セッションIDのCookieの有効期限が切れていると、そのセッション情報にアクセスすることが出来なくなります。  
(最初のリクエストと判断され新しいセッションキーが返ってきます。)  



### 最初の例でセッションを使うと

最初の例でセッションを使うと以下のような処理になります。  

1. 商品Aをカートに入れる  

リクエスト 
``` 
POST /cart/A HTTP/2.0
Host: www.example.org
```

サーバー側コード  
```


```

レスポンス  
```
HTTP/2.0 200 OK
Set-Cookie: SESSION_ID=KJfdafdfadDFJIa  
```


1. 商品Bをカートに入れる  

リクエスト 
``` 
POST /cart/B HTTP/2.0
Host: www.example.org
Cookie: SESSION_ID=KJfdafdfadDFJIa  
```

サーバー側コード  
```


```

レスポンス  
```
HTTP/2.0 200 OK
```

1. 注文する  

リクエスト 
``` 
POST /order HTTP/2.0
Host: www.example.org
Cookie: SESSION_ID=KJfdafdfadDFJIa 
```

サーバー側コード  
```


```

レスポンス  
```
HTTP/2.0 200 OK
```

図  
